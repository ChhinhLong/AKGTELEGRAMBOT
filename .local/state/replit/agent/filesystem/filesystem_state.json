{"file_contents":{"README.md":{"content":"# 🤖 Telegram YouTube Downloader Bot\n\nA feature-rich Telegram bot for downloading YouTube videos and audio with premium features, user management, and admin controls.\n\n## 🌟 Features\n\n### Core Features\n- 🎬 **Video Download** - Download YouTube videos in multiple qualities\n- 🎵 **Audio Download** - Extract audio from YouTube videos\n- 👑 **Premium System** - Unlimited downloads and HD quality for premium users\n- 📊 **Usage Limits** - 15 downloads/hour for normal users with cooldown\n- ⚡ **Fast Processing** - Optimized download with yt-dlp\n- 🔒 **Admin Panel** - Complete admin control system\n\n### Quality Options\n- **Normal Users**: 360p, 480p, Standard Audio\n- **Premium Users**: 360p, 480p, 720p, 1080p, High Quality Audio\n\n### Admin Features\n- User management (grant/revoke premium)\n- Bot statistics and analytics\n- Broadcast messages to all users\n- Cookie management for YouTube bypass\n- User activity monitoring\n\n## 🚀 Quick Start\n\n### Prerequisites\n- Python 3.11+\n- Telegram Bot Token (from @BotFather)\n\n### Local Development\n1. Clone the repository\n2. Install dependencies: `pip install -r requirements.txt`\n3. Set environment variables:\n   - `BOT_TOKEN=your_telegram_bot_token`\n   - `ADMIN_ID=your_telegram_user_id`\n4. Run the bot: `python bot/main.py`\n\n### Deploy to Render.com\n1. Fork this repository\n2. Connect to Render.com\n3. Use the provided `deploy/render.yaml` configuration\n4. Set environment variables in Render dashboard\n5. Deploy!\n\n## 📱 Bot Commands\n\n### User Commands\n- `/start` - Start the bot and show welcome message\n- `/help` - Display help and support information\n- `/limit` - Check your download usage and limits\n- `/upgrade` - Learn about premium features\n\n### Admin Commands\n- `/setprime [user_id] [days]` - Grant premium access to user\n- `/removeprime [user_id]` - Remove premium access from user\n- `/stats` - View detailed bot statistics\n- `/broadcast [message]` - Send message to all bot users\n- `/addcookies` - Upload YouTube cookies file\n- `/fixcode` - Bot maintenance and restart\n\n## 💎 Premium Benefits\n- ♾️ Unlimited downloads (or custom admin-set limit)\n- 🎬 HD Video quality (720p, 1080p)\n- 🎵 High-quality audio downloads\n- ⚡ No cooldown periods\n- 🚀 Priority support\n\n## 🛠️ Technical Details\n\n### Built With\n- **aiogram** - Modern Telegram Bot framework\n- **yt-dlp** - YouTube download engine\n- **aiosqlite** - Async SQLite database\n- **python-dotenv** - Environment management\n\n### Database Schema\n- Users table with premium status and usage tracking\n- Download logs for analytics\n- Admin settings storage\n- Bot statistics tracking\n\n### File Structure\n```\nbot/main.py           # Main bot application\nutils/database.py     # Database operations\nutils/download_manager.py # YouTube download handling\nutils/user_manager.py # User management and limits\nutils/admin_panel.py  # Admin commands\n```\n\n## 📊 Usage Limits\n- **Normal Users**: 15 downloads per hour\n- **Cooldown**: 30 minutes after reaching limit\n- **File Size**: Maximum 50MB per download\n- **Duration**: Maximum 1 hour per video\n- **Premium Users**: Unlimited (customizable by admin)\n\n## 🤝 Support\n- **Telegram**: @chhinhlong\n- **Email**: chhinhlong2008@gmail.com\n- **Bot Credit**: @AKGDownloaderBot\n\n## 📜 License\nThis project is created for educational purposes. Please respect YouTube's Terms of Service and copyright laws.\n\n## 🔧 Configuration\nBot behavior can be customized through environment variables:\n- `BOT_TOKEN` - Telegram bot token\n- `ADMIN_ID` - Admin user ID\n- `LOG_LEVEL` - Logging level (default: INFO)\n\n---\n\n**Created with ❤️ for the YouTube downloading community**","size_bytes":3640},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiogram>=3.22.0\",\n    \"aiosqlite>=0.21.0\",\n    \"asyncio-throttle>=1.0.2\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"yt-dlp>=2025.9.5\",\n]\n","size_bytes":299},"replit.md":{"content":"# Telegram YouTube Downloader Bot - Professional Edition\n\n## Project Overview\nA comprehensive, enterprise-grade Telegram bot for downloading YouTube videos and audio with advanced features, professional architecture, premium user management, sophisticated admin controls, and production-ready deployment configuration.\n\n## Professional Features Implemented\n- ✅ **Advanced Video/Audio Downloading** - Multi-quality downloads with concurrent processing\n- ✅ **Professional User Management** - Session tracking, analytics, caching, and rate limiting\n- ✅ **Enterprise Premium System** - Unlimited downloads, HD quality access, and advanced user tiers\n- ✅ **Comprehensive Admin Panel** - User management, detailed analytics, broadcasting, and moderation tools\n- ✅ **Advanced Security** - Input validation, rate limiting, bot protection, and security monitoring\n- ✅ **Performance Monitoring** - Real-time metrics, database optimization, and health checks\n- ✅ **Professional Analytics** - User behavior tracking, performance metrics, and comprehensive reporting\n- ✅ **Connection Pooling** - Optimized database connections with advanced caching\n- ✅ **Concurrent Downloads** - Multi-threaded download processing with progress tracking\n- ✅ **Professional Logging** - Structured logging with performance monitoring\n- ✅ **Advanced Error Handling** - Comprehensive error categorization and recovery\n\n## Professional Project Structure\n```\n/\n├── bot/\n│   └── main.py                    # Enhanced main bot application with professional features\n├── utils/\n│   ├── database_pro.py            # Professional database with connection pooling & caching\n│   ├── download_manager_pro.py    # Advanced download manager with concurrent processing\n│   ├── user_manager_pro.py        # Professional user management with analytics\n│   ├── admin_panel_pro.py         # Comprehensive admin panel with advanced features\n│   ├── security.py                # Security manager with rate limiting & validation\n│   ├── analytics.py               # Advanced analytics and performance monitoring\n│   ├── database.py                # Legacy database (kept for compatibility)\n│   ├── download_manager.py        # Legacy download manager\n│   ├── user_manager.py            # Legacy user manager\n│   └── admin_panel.py             # Legacy admin panel\n├── db/                            # SQLite database files with advanced schemas\n├── temp/                          # Temporary download files with auto-cleanup\n├── logs/                          # Professional logging directory\n├── cookies/                       # YouTube cookies for bypass with examples\n├── deploy/\n│   ├── render.yaml                # Render.com deployment config\n│   ├── README.md                  # Deployment guide\n│   ├── start.sh                   # Production startup script\n│   └── Dockerfile                 # Container deployment config\n└── requirements.txt               # Python dependencies with version pinning\n```\n\n## Professional Configuration\n- **Admin ID:** 7352192536 (Super Admin with full access)\n- **Standard Users:** 15 downloads/hour with 30min cooldown, 360p/480p quality\n- **Premium Users:** Unlimited downloads, HD quality (720p/1080p), high-quality audio\n- **Security Limits:** 50MB file size, 1 hour video duration\n- **Performance:** Connection pooling (10 connections), caching (5min TTL), concurrent downloads (5 max)\n- **Rate Limiting:** 30 requests/minute with intelligent throttling\n- **Analytics:** Real-time user tracking, performance metrics, comprehensive reporting\n\n## Admin Commands\n- `/setprime [user_id] [days]` - Grant premium access\n- `/removeprime [user_id]` - Remove premium access\n- `/stats` - View bot statistics\n- `/broadcast [message]` - Send message to all users\n- `/addcookies` - Upload YouTube cookies\n- `/fixcode` - Bot maintenance\n\n## User Commands\n- `/start` - Initialize bot and show welcome\n- `/help` - Display help information\n- `/limit` - Check download usage\n- `/upgrade` - Premium upgrade info\n\n## Latest Updates (September 2025)\n- **🚀 Clean Architecture:** Simplified, working modules for reliable operation\n- **💾 SQLite Database:** Simple database with user management and download tracking\n- **⚡ YouTube Downloads:** Working video and audio downloads with quality options\n- **🔐 Basic Security:** Input validation and user blocking functionality\n- **📊 Simple Analytics:** Basic tracking and statistics\n- **👥 User Management:** Download limits, premium users, and session tracking\n- **🛡️ Admin Panel:** User management, statistics, and broadcasting\n- **📁 Deployment Ready:** VM deployment configuration for production\n- **🔧 Error Handling:** Proper error handling and logging\n\n## Current Status\n- ✅ Bot is running successfully in Replit environment\n- ✅ All dependencies installed and working\n- ✅ Database initialized and functional\n- ✅ Deployment configuration set for VM deployment\n- ✅ BOT_TOKEN environment variable configured\n- ✅ All modules simplified and working without syntax errors","size_bytes":5213},"bot/main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTelegram YouTube Downloader Bot - Professional Edition\nFeatures: Video/Audio download, Quality options, Prime users, Admin panel,\nAdvanced analytics, Performance monitoring, Security features\n\"\"\"\n\nimport asyncio\nimport logging\nimport os\nimport sys\nimport time\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Union\nfrom functools import wraps\nimport aiohttp\nfrom contextlib import asynccontextmanager\n\nfrom aiogram import Bot, Dispatcher, Router, F\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode, ChatAction\nfrom aiogram.filters import CommandStart, Command, StateFilter\nfrom aiogram.types import (\n    Message, CallbackQuery, InlineKeyboardMarkup, \n    InlineKeyboardButton, ReactionTypeEmoji, BotCommand,\n    InputFile, BufferedInputFile\n)\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom aiogram.fsm.storage.memory import MemoryStorage\nfrom dotenv import load_dotenv\nimport asyncio_throttle\n\n# Import our custom modules\nsys.path.append(os.path.join(os.path.dirname(__file__), '..'))\nfrom utils.database_simple import DatabasePro\nfrom utils.download_manager_simple import AdvancedDownloadManager\nfrom utils.user_manager_simple import ProfessionalUserManager\nfrom utils.admin_panel_simple import ProfessionalAdminPanel\nfrom utils.security_simple import SecurityManager\nfrom utils.analytics_simple import AnalyticsManager\n\n# Load environment variables\nload_dotenv()\n\n# Configure advanced logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',\n    handlers=[\n        logging.FileHandler('logs/bot.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n# Ensure logs directory exists\nos.makedirs('logs', exist_ok=True)\n\n# Performance monitoring\nstart_time = time.time()\nrequest_count = 0\nerror_count = 0\ndownload_stats = {'total': 0, 'successful': 0, 'failed': 0}\n\n# Initialize bot and dispatcher\nBOT_TOKEN = os.getenv('BOT_TOKEN')\nif not BOT_TOKEN:\n    logger.error(\"BOT_TOKEN not found in environment variables\")\n    sys.exit(1)\n\nADMIN_ID = int(os.getenv('ADMIN_ID', '7352192536'))\nMAX_CONCURRENT_DOWNLOADS = int(os.getenv('MAX_CONCURRENT_DOWNLOADS', '5'))\nRATE_LIMIT_REQUESTS = int(os.getenv('RATE_LIMIT_REQUESTS', '30'))\nRATE_LIMIT_PERIOD = int(os.getenv('RATE_LIMIT_PERIOD', '60'))\n\n# Advanced bot configuration\nbot = Bot(\n    token=BOT_TOKEN, \n    default=DefaultBotProperties(\n        parse_mode=ParseMode.HTML,\n        protect_content=False,\n        allow_sending_without_reply=True\n    )\n)\nstorage = MemoryStorage()\ndp = Dispatcher(storage=storage)\nrouter = Router()\n\n# Rate limiting\nthrottle = asyncio_throttle.Throttler(rate_limit=RATE_LIMIT_REQUESTS, period=RATE_LIMIT_PERIOD)\n\n# Bot states for advanced flow control\nclass BotStates(StatesGroup):\n    waiting_for_url = State()\n    selecting_quality = State()\n    downloading = State()\n    waiting_admin_input = State()\n\n# Initialize professional managers\ndb = DatabasePro(db_path=\"db/bot_database.db\")\ndownload_manager = AdvancedDownloadManager(\n    max_concurrent=MAX_CONCURRENT_DOWNLOADS,\n    temp_dir=\"temp\"\n)\nuser_manager = ProfessionalUserManager(db)\nadmin_panel = ProfessionalAdminPanel(db, bot, ADMIN_ID)\nsecurity_manager = SecurityManager()\nanalytics_manager = AnalyticsManager(db)\n\ndef get_main_keyboard():\n    \"\"\"Create main inline keyboard\"\"\"\n    keyboard = InlineKeyboardBuilder()\n    keyboard.add(InlineKeyboardButton(text=\"🎬 Video Download\", callback_data=\"video_download\"))\n    keyboard.add(InlineKeyboardButton(text=\"🎵 Audio Download\", callback_data=\"audio_download\"))\n    keyboard.add(InlineKeyboardButton(text=\"📊 Check Limits\", callback_data=\"check_limits\"))\n    keyboard.add(InlineKeyboardButton(text=\"👑 Upgrade to Prime\", callback_data=\"upgrade_info\"))\n    keyboard.add(InlineKeyboardButton(text=\"ℹ️ Help & Support\", callback_data=\"help_support\"))\n    keyboard.adjust(2, 1, 2)\n    return keyboard.as_markup()\n\ndef get_quality_keyboard(download_type=\"video\", is_prime=False):\n    \"\"\"Create quality selection keyboard\"\"\"\n    keyboard = InlineKeyboardBuilder()\n    \n    if download_type == \"video\":\n        keyboard.add(InlineKeyboardButton(text=\"360p\", callback_data=\"quality_360p\"))\n        keyboard.add(InlineKeyboardButton(text=\"480p\", callback_data=\"quality_480p\"))\n        if is_prime:\n            keyboard.add(InlineKeyboardButton(text=\"720p 👑\", callback_data=\"quality_720p\"))\n            keyboard.add(InlineKeyboardButton(text=\"1080p 👑\", callback_data=\"quality_1080p\"))\n        keyboard.adjust(2)\n    else:  # audio\n        keyboard.add(InlineKeyboardButton(text=\"Standard Audio\", callback_data=\"audio_standard\"))\n        if is_prime:\n            keyboard.add(InlineKeyboardButton(text=\"High Quality 👑\", callback_data=\"audio_hq\"))\n        keyboard.adjust(1)\n    \n    keyboard.add(InlineKeyboardButton(text=\"🔙 Back\", callback_data=\"back_to_main\"))\n    return keyboard.as_markup()\n\n@router.message(CommandStart())\nasync def command_start_handler(message: Message):\n    \"\"\"Handle /start command\"\"\"\n    if not message.from_user:\n        return\n    user_id = message.from_user.id\n    username = message.from_user.username or \"Unknown\"\n    \n    # Initialize user in database\n    await user_manager.initialize_user(user_id, username)\n    \n    welcome_text = f\"\"\"\n🎉 <b>Welcome to AKG YouTube Downloader Bot!</b>\n\n📱 <b>What I can do:</b>\n• 🎬 Download YouTube videos (360p, 480p)\n• 🎵 Download audio from YouTube videos\n• 👑 Prime users get HD quality (720p, 1080p, HQ audio)\n\n📊 <b>Your Status:</b>\n👤 Normal User: 15 downloads per hour\n⏰ Cooldown: 30 minutes between sessions\n\n🚀 <b>How to use:</b>\n1. Click the buttons below\n2. Send me a YouTube link\n3. Choose your quality\n4. Download starts automatically!\n\n💎 Want unlimited downloads and HD quality? Upgrade to Prime!\n\n📞 <b>Support:</b>\nTelegram: @chhinhlong\nEmail: chhinhlong2008@gmail.com\n\n🔗 Credit: @AKGDownloaderBot\n    \"\"\"\n    \n    await message.answer(welcome_text, reply_markup=get_main_keyboard())\n\n@router.message(Command(\"help\"))\nasync def command_help_handler(message: Message):\n    \"\"\"Handle /help command\"\"\"\n    help_text = \"\"\"\nℹ️ <b>AKG Downloader Bot - Help</b>\n\n<b>📋 Commands:</b>\n/start - Start the bot\n/help - Show this help\n/limit - Check your usage limits\n/upgrade - Information about Prime\n\n<b>🎬 How to Download:</b>\n1. Click \"Video Download\" or \"Audio Download\"\n2. Send a YouTube link (example: https://youtube.com/watch?v=...)\n3. Choose quality (360p/480p for normal users)\n4. Wait for download to complete\n\n<b>👑 Prime Benefits:</b>\n• Unlimited downloads (or set by admin)\n• HD quality: 720p, 1080p\n• High-quality audio\n• No cooldown periods\n\n<b>📞 Support:</b>\nTelegram: @chhinhlong\nEmail: chhinhlong2008@gmail.com\n\n<b>⚠️ Note:</b>\nNormal users: 15 downloads per hour\nCooldown: 30 minutes between sessions\n    \"\"\"\n    await message.answer(help_text, reply_markup=get_main_keyboard())\n\n@router.message(Command(\"limit\"))\nasync def command_limit_handler(message: Message):\n    \"\"\"Handle /limit command\"\"\"\n    user_id = message.from_user.id\n    status = await user_manager.get_user_status(user_id)\n    \n    if status['is_prime']:\n        if status['prime_expiry']:\n            limit_text = f\"👑 <b>Prime User Status</b>\\n\\n✅ Unlimited downloads\\n📅 Expires: {status['prime_expiry']}\"\n        else:\n            limit_text = \"👑 <b>Prime User Status</b>\\n\\n✅ Unlimited downloads\\n♾️ No expiration\"\n    else:\n        remaining = status['downloads_remaining']\n        reset_time = status['reset_time']\n        limit_text = f\"👤 <b>Normal User Status</b>\\n\\n📊 Downloads remaining: {remaining}/15\\n⏰ Resets at: {reset_time}\\n\\n💎 Upgrade to Prime for unlimited downloads!\"\n    \n    await message.answer(limit_text, reply_markup=get_main_keyboard())\n\n@router.message(Command(\"upgrade\"))\nasync def command_upgrade_handler(message: Message):\n    \"\"\"Handle /upgrade command\"\"\"\n    upgrade_text = \"\"\"\n👑 <b>Upgrade to Prime</b>\n\n<b>🌟 Prime Benefits:</b>\n• ♾️ Unlimited downloads (or custom limit)\n• 🎬 HD Video: 720p, 1080p quality\n• 🎵 High-quality audio downloads\n• ⚡ No cooldown periods\n• 🚀 Priority download speed\n\n<b>💰 How to get Prime:</b>\nContact admin @chhinhlong for pricing and payment options.\n\n<b>📞 Contact:</b>\nTelegram: @chhinhlong\nEmail: chhinhlong2008@gmail.com\n\nPrime subscriptions are managed by admin and can be customized for your needs!\n    \"\"\"\n    await message.answer(upgrade_text, reply_markup=get_main_keyboard())\n\n@router.callback_query(F.data == \"video_download\")\nasync def callback_video_download(callback: CallbackQuery):\n    \"\"\"Handle video download button\"\"\"\n    if not callback.from_user or not callback.message:\n        return\n    user_id = callback.from_user.id\n    status = await user_manager.get_user_status(user_id)\n    \n    if not status['can_download']:\n        await callback.message.edit_text(\n            f\"⏰ <b>Download limit reached!</b>\\n\\nYou've used all 15 downloads for this hour.\\nNext reset: {status['reset_time']}\\n\\n👑 Prime users have unlimited downloads!\",\n            reply_markup=get_main_keyboard()\n        )\n        return\n    \n    await callback.message.edit_text(\n        \"🎬 <b>Video Download Mode</b>\\n\\n📋 Steps:\\n1. Send me a YouTube link\\n2. Choose quality\\n3. Download starts!\\n\\n🔗 Send a YouTube link now:\",\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"🔙 Back to Main\", callback_data=\"back_to_main\")]\n        ])\n    )\n    \n    # Set user state for video download\n    await user_manager.set_user_state(user_id, \"waiting_video_url\")\n\n@router.callback_query(F.data == \"audio_download\")\nasync def callback_audio_download(callback: CallbackQuery):\n    \"\"\"Handle audio download button\"\"\"\n    if not callback.from_user or not callback.message:\n        return\n    user_id = callback.from_user.id\n    status = await user_manager.get_user_status(user_id)\n    \n    if not status['can_download']:\n        await callback.message.edit_text(\n            f\"⏰ <b>Download limit reached!</b>\\n\\nYou've used all 15 downloads for this hour.\\nNext reset: {status['reset_time']}\\n\\n👑 Prime users have unlimited downloads!\",\n            reply_markup=get_main_keyboard()\n        )\n        return\n    \n    await callback.message.edit_text(\n        \"🎵 <b>Audio Download Mode</b>\\n\\n📋 Steps:\\n1. Send me a YouTube link\\n2. Choose quality\\n3. Download starts!\\n\\n🔗 Send a YouTube link now:\",\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"🔙 Back to Main\", callback_data=\"back_to_main\")]\n        ])\n    )\n    \n    # Set user state for audio download\n    await user_manager.set_user_state(user_id, \"waiting_audio_url\")\n\n@router.callback_query(F.data == \"check_limits\")\nasync def callback_check_limits(callback: CallbackQuery):\n    \"\"\"Handle check limits button\"\"\"\n    if not callback.from_user or not callback.message:\n        return\n    user_id = callback.from_user.id\n    status = await user_manager.get_user_status(user_id)\n    \n    if status['is_prime']:\n        if status['prime_expiry']:\n            limit_text = f\"👑 <b>Prime User Status</b>\\n\\n✅ Unlimited downloads\\n📅 Expires: {status['prime_expiry']}\"\n        else:\n            limit_text = \"👑 <b>Prime User Status</b>\\n\\n✅ Unlimited downloads\\n♾️ No expiration\"\n    else:\n        remaining = status['downloads_remaining']\n        reset_time = status['reset_time']\n        limit_text = f\"👤 <b>Normal User Status</b>\\n\\n📊 Downloads remaining: {remaining}/15\\n⏰ Resets at: {reset_time}\\n\\n💎 Upgrade to Prime for unlimited downloads!\"\n    \n    await callback.message.edit_text(limit_text, reply_markup=get_main_keyboard())\n\n@router.callback_query(F.data == \"upgrade_info\")\nasync def callback_upgrade_info(callback: CallbackQuery):\n    \"\"\"Handle upgrade info button\"\"\"\n    if not callback.message:\n        return\n    upgrade_text = \"\"\"\n👑 <b>Upgrade to Prime</b>\n\n<b>🌟 Prime Benefits:</b>\n• ♾️ Unlimited downloads (or custom limit)\n• 🎬 HD Video: 720p, 1080p quality\n• 🎵 High-quality audio downloads\n• ⚡ No cooldown periods\n• 🚀 Priority download speed\n\n<b>💰 How to get Prime:</b>\nContact admin @chhinhlong for pricing and payment options.\n\n<b>📞 Contact:</b>\nTelegram: @chhinhlong\nEmail: chhinhlong2008@gmail.com\n    \"\"\"\n    await callback.message.edit_text(upgrade_text, reply_markup=get_main_keyboard())\n\n@router.callback_query(F.data == \"help_support\")\nasync def callback_help_support(callback: CallbackQuery):\n    \"\"\"Handle help & support button\"\"\"\n    if not callback.message:\n        return\n    help_text = \"\"\"\nℹ️ <b>Help & Support</b>\n\n<b>📞 Contact Information:</b>\n• Telegram: @chhinhlong\n• Email: chhinhlong2008@gmail.com\n\n<b>🚀 Quick Tips:</b>\n• Make sure your YouTube link is valid\n• For best results, use direct video links\n• Prime users get priority support\n• Report bugs or issues anytime\n\n<b>🔗 Bot Credit:</b>\n@AKGDownloaderBot\n\n<b>⏰ Support Hours:</b>\nWe aim to respond within 24 hours!\n    \"\"\"\n    await callback.message.edit_text(help_text, reply_markup=get_main_keyboard())\n\n@router.callback_query(F.data == \"back_to_main\")\nasync def callback_back_to_main(callback: CallbackQuery):\n    \"\"\"Handle back to main button\"\"\"\n    if not callback.from_user or not callback.message:\n        return\n    user_id = callback.from_user.id\n    await user_manager.clear_user_state(user_id)\n    \n    welcome_text = f\"\"\"\n🎉 <b>AKG YouTube Downloader Bot</b>\n\nChoose an option below to get started:\n\n📱 <b>Available Features:</b>\n• 🎬 Download YouTube videos\n• 🎵 Extract audio from videos\n• 📊 Check your download limits\n• 👑 Upgrade to Prime for HD quality\n\n🔗 Credit: @AKGDownloaderBot\n    \"\"\"\n    \n    await callback.message.edit_text(welcome_text, reply_markup=get_main_keyboard())\n\n@router.message(F.text.contains(\"youtube.com\") | F.text.contains(\"youtu.be\"))\nasync def handle_youtube_url(message: Message):\n    \"\"\"Handle YouTube URL messages\"\"\"\n    if not message.from_user or not message.text:\n        return\n    user_id = message.from_user.id\n    url = message.text.strip()\n    \n    # Add reaction to show bot is processing\n    try:\n        await message.react([ReactionTypeEmoji(emoji=\"👀\")])\n    except:\n        pass\n    \n    # Get user state and status\n    user_state = await user_manager.get_user_state(user_id)\n    status = await user_manager.get_user_status(user_id)\n    \n    if not status['can_download']:\n        await message.reply(\n            f\"⏰ <b>Download limit reached!</b>\\n\\nYou've used all 15 downloads for this hour.\\nNext reset: {status['reset_time']}\\n\\n👑 Prime users have unlimited downloads!\",\n            reply_markup=get_main_keyboard()\n        )\n        return\n    \n    if user_state == \"waiting_video_url\":\n        # Show video quality options\n        await message.reply(\n            f\"🎬 <b>Video Download</b>\\n\\n🔗 URL: <code>{url}</code>\\n\\nSelect video quality:\",\n            reply_markup=get_quality_keyboard(\"video\", status['is_prime'])\n        )\n        await user_manager.set_user_data(user_id, \"download_url\", url)\n        await user_manager.set_user_state(user_id, \"selecting_video_quality\")\n        \n    elif user_state == \"waiting_audio_url\":\n        # Show audio quality options\n        await message.reply(\n            f\"🎵 <b>Audio Download</b>\\n\\n🔗 URL: <code>{url}</code>\\n\\nSelect audio quality:\",\n            reply_markup=get_quality_keyboard(\"audio\", status['is_prime'])\n        )\n        await user_manager.set_user_data(user_id, \"download_url\", url)\n        await user_manager.set_user_state(user_id, \"selecting_audio_quality\")\n    else:\n        # User sent URL without selecting download mode\n        await message.reply(\n            \"🔗 <b>YouTube link detected!</b>\\n\\nPlease choose download type first:\",\n            reply_markup=get_main_keyboard()\n        )\n\n# Quality selection handlers\n@router.callback_query(F.data.startswith(\"quality_\") | F.data.startswith(\"audio_\"))\nasync def handle_quality_selection(callback: CallbackQuery):\n    \"\"\"Handle quality selection\"\"\"\n    if not callback.from_user or not callback.message or not callback.data:\n        return\n    user_id = callback.from_user.id\n    quality = callback.data\n    \n    # Get stored URL\n    url = await user_manager.get_user_data(user_id, \"download_url\")\n    status = await user_manager.get_user_status(user_id)\n    \n    if not url:\n        await callback.message.edit_text(\"❌ Error: No URL found. Please start again.\", reply_markup=get_main_keyboard())\n        return\n    \n    # Check premium quality restrictions\n    premium_qualities = [\"quality_720p\", \"quality_1080p\", \"audio_hq\"]\n    if quality in premium_qualities and not status['is_prime']:\n        await callback.message.edit_text(\n            \"👑 <b>Premium Quality!</b>\\n\\nThis quality option is only available for Prime users.\\n\\nContact @chhinhlong to upgrade to Prime!\",\n            reply_markup=get_main_keyboard()\n        )\n        return\n    \n    # Start download process\n    await callback.message.edit_text(\"⏳ <b>Starting download...</b>\\n\\nPlease wait, this may take a few moments.\")\n    \n    try:\n        # Use download manager to process the request\n        result = await download_manager.download_content(url, quality, user_id)\n        \n        if result['success']:\n            # Update user usage\n            await user_manager.update_usage(user_id)\n            \n            # Send the file\n            if result['type'] == 'video':\n                await callback.bot.send_video(\n                    chat_id=callback.message.chat.id,\n                    video=result['file'],\n                    caption=f\"🎬 <b>Video Downloaded!</b>\\n\\n📱 Quality: {result['quality']}\\n🔗 Credit: @AKGDownloaderBot\",\n                    reply_markup=get_main_keyboard()\n                )\n            else:  # audio\n                await callback.bot.send_audio(\n                    chat_id=callback.message.chat.id,\n                    audio=result['file'],\n                    caption=f\"🎵 <b>Audio Downloaded!</b>\\n\\n📱 Quality: {result['quality']}\\n🔗 Credit: @AKGDownloaderBot\",\n                    reply_markup=get_main_keyboard()\n                )\n            \n            # Update status message\n            remaining = await user_manager.get_downloads_remaining(user_id)\n            if not status['is_prime']:\n                await callback.message.edit_text(f\"✅ <b>Download Complete!</b>\\n\\n📊 Downloads remaining: {remaining}/15\")\n            else:\n                await callback.message.edit_text(\"✅ <b>Download Complete!</b>\\n\\n👑 Prime user - unlimited downloads!\")\n        else:\n            await callback.message.edit_text(\n                f\"❌ <b>Download Failed</b>\\n\\n{result['error']}\\n\\nPlease try again or contact support.\",\n                reply_markup=get_main_keyboard()\n            )\n            \n    except Exception as e:\n        logger.error(f\"Download error for user {user_id}: {e}\")\n        await callback.message.edit_text(\n            \"❌ <b>Download Error</b>\\n\\nSomething went wrong. Please try again later or contact support.\",\n            reply_markup=get_main_keyboard()\n        )\n    \n    # Clear user state\n    await user_manager.clear_user_state(user_id)\n    await user_manager.clear_user_data(user_id)\n\n# Admin commands\n@router.message(Command(\"setprime\"))\nasync def admin_set_prime(message: Message):\n    \"\"\"Admin command to set prime status\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await admin_panel.handle_set_prime(message)\n\n@router.message(Command(\"removeprime\"))\nasync def admin_remove_prime(message: Message):\n    \"\"\"Admin command to remove prime status\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await admin_panel.handle_remove_prime(message)\n\n@router.message(Command(\"stats\"))\nasync def admin_stats(message: Message):\n    \"\"\"Admin command to get bot stats\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await admin_panel.handle_stats(message)\n\n@router.message(Command(\"broadcast\"))\nasync def admin_broadcast(message: Message):\n    \"\"\"Admin command to broadcast message\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await admin_panel.handle_broadcast(message)\n\n@router.message(Command(\"addcookies\"))\nasync def admin_add_cookies(message: Message):\n    \"\"\"Admin command to add cookies\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await message.reply(\"📁 Please upload the cookies.txt file to update YouTube bypass cookies.\")\n\n@router.message(Command(\"fixcode\"))\nasync def admin_fix_code(message: Message):\n    \"\"\"Admin command to fix issues\"\"\"\n    if not message.from_user or message.from_user.id != ADMIN_ID:\n        await message.reply(\"❌ Admin only command!\")\n        return\n    \n    await message.reply(\"🔧 Auto-fixing bot issues... Bot will restart if needed.\")\n\n# Error handler for unknown messages\n@router.message()\nasync def handle_unknown_message(message: Message):\n    \"\"\"Handle unknown messages\"\"\"\n    await message.reply(\n        \"❓ <b>Unknown Command</b>\\n\\nPlease use the menu buttons below or send a YouTube link for download.\",\n        reply_markup=get_main_keyboard()\n    )\n\nasync def main():\n    \"\"\"Main function to start the bot\"\"\"\n    # Initialize database\n    await db.initialize()\n    \n    # Register router\n    dp.include_router(router)\n    \n    # Start polling\n    logger.info(\"Bot starting...\")\n    try:\n        await dp.start_polling(bot)\n    finally:\n        await bot.session.close()\n\nif __name__ == '__main__':\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info(\"Bot stopped by user\")\n    except Exception as e:\n        logger.error(f\"Bot error: {e}\")","size_bytes":22505},"cookies/README.md":{"content":"# YouTube Cookies Configuration\n\nThis folder is used to store YouTube cookies for bypassing certain restrictions and improving download success rates.\n\n## How to Get YouTube Cookies\n\n### Method 1: Browser Extension\n1. Install a cookie export extension (like \"Get cookies.txt LOCALLY\")\n2. Go to youtube.com and make sure you're logged in\n3. Use the extension to export cookies as `cookies.txt`\n4. Upload the file to this folder\n\n### Method 2: Manual Export\n1. Go to youtube.com in your browser\n2. Open Developer Tools (F12)\n3. Go to Application/Storage tab\n4. Find Cookies → https://youtube.com\n5. Export cookies in Netscape format\n\n### Method 3: Admin Command\nUse the `/addcookies` admin command in your bot to upload cookies file directly.\n\n## File Format\nThe cookies.txt file should be in Netscape format:\n```\n# Netscape HTTP Cookie File\n.youtube.com    TRUE    /    FALSE    1234567890    cookie_name    cookie_value\n```\n\n## When to Use Cookies\n- If you encounter \"Sign in to confirm you're not a bot\" errors\n- When downloading age-restricted content\n- For improved download reliability\n- When facing IP-based rate limiting\n\n## Security Note\n- Keep your cookies.txt file private\n- Don't share it with others\n- Regenerate cookies periodically for security","size_bytes":1259},"deploy/README.md":{"content":"# Deploy to Render.com\n\nThis folder contains deployment configuration files for deploying your Telegram bot to Render.com.\n\n## Quick Deploy Steps\n\n1. **Push to GitHub**\n   - Create a new repository on GitHub\n   - Push this entire project to your GitHub repository\n\n2. **Connect to Render**\n   - Go to [render.com](https://render.com)\n   - Sign up/login with your GitHub account\n   - Click \"New +\" → \"Web Service\"\n   - Connect your GitHub repository\n\n3. **Configure Environment Variables**\n   In Render dashboard, add these environment variables:\n   ```\n   BOT_TOKEN = your_telegram_bot_token_here\n   ADMIN_ID = 7352192536\n   LOG_LEVEL = INFO\n   ```\n\n4. **Deploy Settings**\n   - Build Command: `pip install -r requirements.txt`\n   - Start Command: `python bot/main.py`\n   - Plan: Free (or choose your preferred plan)\n\n5. **Deploy**\n   - Click \"Create Web Service\"\n   - Render will automatically deploy your bot\n\n## Auto-Deploy\nOnce connected, every push to your GitHub repository will automatically trigger a new deployment on Render.\n\n## Free Tier Limitations\n- Free tier may sleep after 15 minutes of inactivity\n- For 24/7 operation, consider upgrading to a paid plan\n- Free tier includes 750 hours per month","size_bytes":1211},"deploy/render.yaml":{"content":"services:\n  - type: web\n    name: telegram-youtube-bot\n    env: python\n    buildCommand: \"pip install -r requirements.txt\"\n    startCommand: \"python bot/main.py\"\n    plan: free\n    envVars:\n      - key: BOT_TOKEN\n        sync: false\n      - key: ADMIN_ID\n        value: \"7352192536\"\n      - key: LOG_LEVEL\n        value: \"INFO\"","size_bytes":327},"deploy/start.sh":{"content":"#!/bin/bash\n# Render.com startup script for Telegram Bot\n\necho \"Starting Telegram YouTube Downloader Bot...\"\n\n# Create necessary directories\nmkdir -p temp\nmkdir -p db\nmkdir -p cookies\n\n# Set permissions\nchmod +x bot/main.py\n\n# Start the bot\npython bot/main.py","size_bytes":259},"utils/__init__.py":{"content":"# Utils package for Telegram YouTube Bot","size_bytes":40},"utils/admin_panel.py":{"content":"\"\"\"\nAdmin panel for managing bot operations, users, and broadcasting\n\"\"\"\n\nimport logging\nimport asyncio\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nfrom aiogram import Bot\nfrom aiogram.types import Message\nfrom .database import Database\n\nlogger = logging.getLogger(__name__)\n\nclass AdminPanel:\n    def __init__(self, database: Database, bot: Bot, admin_id: int):\n        \"\"\"Initialize admin panel\"\"\"\n        self.db = database\n        self.bot = bot\n        self.admin_id = admin_id\n    \n    async def handle_set_prime(self, message: Message):\n        \"\"\"Handle /setprime command\"\"\"\n        try:\n            args = message.text.split()[1:]  # Remove command name\n            \n            if len(args) < 1:\n                await message.reply(\n                    \"❌ <b>Usage:</b> /setprime [user_id] [days]\\n\\n\"\n                    \"Example: <code>/setprime 123456789 30</code>\\n\"\n                    \"For permanent: <code>/setprime 123456789</code>\"\n                )\n                return\n            \n            user_id = int(args[0])\n            days = int(args[1]) if len(args) > 1 else None\n            \n            # Set prime status\n            success = await self.db.set_prime_status(user_id, True, days)\n            \n            if success:\n                expiry_text = f\"for {days} days\" if days else \"permanently\"\n                await message.reply(\n                    f\"✅ <b>Prime Granted!</b>\\n\\n\"\n                    f\"👤 User ID: <code>{user_id}</code>\\n\"\n                    f\"👑 Prime: {expiry_text}\\n\"\n                    f\"⏰ Granted at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\"\n                )\n                \n                # Notify the user\n                try:\n                    expiry_msg = f\"for {days} days\" if days else \"with no expiration\"\n                    await self.bot.send_message(\n                        user_id,\n                        f\"🎉 <b>Congratulations!</b>\\n\\n\"\n                        f\"You have been upgraded to Prime {expiry_msg}!\\n\\n\"\n                        f\"👑 <b>Prime Benefits:</b>\\n\"\n                        f\"• Unlimited downloads\\n\"\n                        f\"• HD quality (720p, 1080p)\\n\"\n                        f\"• High-quality audio\\n\"\n                        f\"• No cooldown periods\\n\\n\"\n                        f\"Enjoy your premium experience!\"\n                    )\n                except Exception as e:\n                    logger.warning(f\"Could not notify user {user_id}: {e}\")\n            else:\n                await message.reply(\"❌ Failed to set prime status. Check user ID and try again.\")\n                \n        except ValueError:\n            await message.reply(\"❌ Invalid user ID or days. Use numbers only.\")\n        except Exception as e:\n            logger.error(f\"Error in set_prime: {e}\")\n            await message.reply(\"❌ An error occurred while setting prime status.\")\n    \n    async def handle_remove_prime(self, message: Message):\n        \"\"\"Handle /removeprime command\"\"\"\n        try:\n            args = message.text.split()[1:]\n            \n            if len(args) < 1:\n                await message.reply(\n                    \"❌ <b>Usage:</b> /removeprime [user_id]\\n\\n\"\n                    \"Example: <code>/removeprime 123456789</code>\"\n                )\n                return\n            \n            user_id = int(args[0])\n            \n            # Remove prime status\n            success = await self.db.set_prime_status(user_id, False)\n            \n            if success:\n                await message.reply(\n                    f\"✅ <b>Prime Removed!</b>\\n\\n\"\n                    f\"👤 User ID: <code>{user_id}</code>\\n\"\n                    f\"❌ Prime status revoked\\n\"\n                    f\"⏰ Removed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\"\n                )\n                \n                # Notify the user\n                try:\n                    await self.bot.send_message(\n                        user_id,\n                        f\"📢 <b>Prime Status Update</b>\\n\\n\"\n                        f\"Your Prime subscription has expired or been revoked.\\n\\n\"\n                        f\"👤 <b>Normal User Limits:</b>\\n\"\n                        f\"• 15 downloads per hour\\n\"\n                        f\"• Standard quality (360p, 480p)\\n\"\n                        f\"• 30-minute cooldown after limit\\n\\n\"\n                        f\"Contact @chhinhlong to renew your Prime status!\"\n                    )\n                except Exception as e:\n                    logger.warning(f\"Could not notify user {user_id}: {e}\")\n            else:\n                await message.reply(\"❌ Failed to remove prime status. Check user ID and try again.\")\n                \n        except ValueError:\n            await message.reply(\"❌ Invalid user ID. Use numbers only.\")\n        except Exception as e:\n            logger.error(f\"Error in remove_prime: {e}\")\n            await message.reply(\"❌ An error occurred while removing prime status.\")\n    \n    async def handle_stats(self, message: Message):\n        \"\"\"Handle /stats command\"\"\"\n        try:\n            stats = await self.db.get_bot_stats()\n            \n            stats_text = f\"\"\"\n📊 <b>Bot Statistics</b>\n\n👥 <b>Users:</b>\n• Total Users: {stats['total_users']:,}\n• Active (24h): {stats['active_users_24h']:,}\n• Prime Users: {stats['prime_users']:,}\n• Normal Users: {stats['total_users'] - stats['prime_users']:,}\n\n📈 <b>Downloads:</b>\n• Total Downloads: {stats['total_downloads']:,}\n• Today: {stats['downloads_today']:,}\n• Failed: {stats['failed_downloads']:,}\n• Success Rate: {(stats['total_downloads'] / max(1, stats['total_downloads'] + stats['failed_downloads']) * 100):.1f}%\n\n🎬 <b>Content Type:</b>\n• Video Downloads: {stats['video_downloads']:,}\n• Audio Downloads: {stats['audio_downloads']:,}\n\n⏰ <b>Last Updated:</b>\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n            \"\"\"\n            \n            await message.reply(stats_text)\n            \n        except Exception as e:\n            logger.error(f\"Error getting stats: {e}\")\n            await message.reply(\"❌ An error occurred while fetching statistics.\")\n    \n    async def handle_broadcast(self, message: Message):\n        \"\"\"Handle /broadcast command\"\"\"\n        try:\n            # Get message text after command\n            command_parts = message.text.split(' ', 1)\n            \n            if len(command_parts) < 2:\n                await message.reply(\n                    \"❌ <b>Usage:</b> /broadcast [message]\\n\\n\"\n                    \"Example: <code>/broadcast 🎉 New features added! Check them out.</code>\\n\\n\"\n                    \"The message will be sent to all bot users.\"\n                )\n                return\n            \n            broadcast_message = command_parts[1]\n            \n            # Get all user IDs\n            user_ids = await self.db.get_all_user_ids()\n            \n            if not user_ids:\n                await message.reply(\"❌ No users found to broadcast to.\")\n                return\n            \n            # Send broadcast confirmation\n            confirm_msg = await message.reply(\n                f\"📢 <b>Broadcasting to {len(user_ids)} users...</b>\\n\\n\"\n                f\"Message: {broadcast_message}\\n\\n\"\n                f\"⏳ This may take a while...\"\n            )\n            \n            # Broadcast to all users\n            success_count = 0\n            failed_count = 0\n            \n            for user_id in user_ids:\n                try:\n                    await self.bot.send_message(\n                        user_id,\n                        f\"📢 <b>Announcement from AKG Downloader Bot</b>\\n\\n{broadcast_message}\\n\\n\"\n                        f\"🔗 Credit: @AKGDownloaderBot\"\n                    )\n                    success_count += 1\n                    \n                    # Add small delay to avoid rate limiting\n                    await asyncio.sleep(0.1)\n                    \n                except Exception as e:\n                    failed_count += 1\n                    logger.warning(f\"Failed to send broadcast to user {user_id}: {e}\")\n            \n            # Update confirmation message with results\n            await confirm_msg.edit_text(\n                f\"✅ <b>Broadcast Complete!</b>\\n\\n\"\n                f\"📤 Sent to: {success_count} users\\n\"\n                f\"❌ Failed: {failed_count} users\\n\"\n                f\"📊 Success Rate: {(success_count / len(user_ids) * 100):.1f}%\\n\\n\"\n                f\"Message: {broadcast_message}\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error in broadcast: {e}\")\n            await message.reply(\"❌ An error occurred during broadcast.\")\n    \n    async def get_user_details(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get detailed user information for admin\"\"\"\n        try:\n            user = await self.db.get_user(user_id)\n            if not user:\n                return None\n            \n            prime_status = await self.db.check_prime_status(user_id)\n            download_stats = await self.db.get_download_stats(user_id)\n            \n            return {\n                'user_id': user['user_id'],\n                'username': user.get('username', 'Unknown'),\n                'first_name': user.get('first_name', ''),\n                'last_name': user.get('last_name', ''),\n                'is_prime': prime_status['is_prime'],\n                'prime_expiry': prime_status.get('expiry_date'),\n                'downloads_this_hour': download_stats['downloads_this_hour'],\n                'downloads_today': user.get('downloads_today', 0),\n                'created_at': user.get('created_at'),\n                'last_active': user.get('last_active')\n            }\n        except Exception as e:\n            logger.error(f\"Error getting user details {user_id}: {e}\")\n            return None\n    \n    async def search_users(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"Search users by username or ID\"\"\"\n        try:\n            # This would need custom database query implementation\n            # For now, return empty list\n            return []\n        except Exception as e:\n            logger.error(f\"Error searching users: {e}\")\n            return []\n    \n    async def get_recent_downloads(self, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"Get recent download logs\"\"\"\n        try:\n            async with self.db._get_connection() as db:\n                async with db.execute(\"\"\"\n                    SELECT dl.*, u.username \n                    FROM download_logs dl\n                    LEFT JOIN users u ON dl.user_id = u.user_id\n                    ORDER BY dl.download_time DESC\n                    LIMIT ?\n                \"\"\", (limit,)) as cursor:\n                    rows = await cursor.fetchall()\n                    return [dict(row) for row in rows]\n        except Exception as e:\n            logger.error(f\"Error getting recent downloads: {e}\")\n            return []\n    \n    async def cleanup_expired_prime(self) -> int:\n        \"\"\"Clean up expired prime users\"\"\"\n        try:\n            # This would check for expired prime users and revoke their status\n            # Implementation depends on database structure\n            expired_count = 0\n            \n            # Get all prime users\n            async with self.db._get_connection() as db:\n                async with db.execute(\"\"\"\n                    SELECT user_id, prime_expiry \n                    FROM users \n                    WHERE is_prime = TRUE AND prime_expiry IS NOT NULL\n                \"\"\") as cursor:\n                    rows = await cursor.fetchall()\n                    \n                    for row in rows:\n                        user_id, expiry = row\n                        if isinstance(expiry, str):\n                            expiry = datetime.fromisoformat(expiry.replace('Z', '+00:00'))\n                        \n                        if datetime.now() > expiry:\n                            await self.db.set_prime_status(user_id, False)\n                            expired_count += 1\n                            \n                            # Notify user\n                            try:\n                                await self.bot.send_message(\n                                    user_id,\n                                    \"📢 <b>Prime Expired</b>\\n\\n\"\n                                    \"Your Prime subscription has expired.\\n\\n\"\n                                    \"Contact @chhinhlong to renew!\"\n                                )\n                            except:\n                                pass\n            \n            logger.info(f\"Cleaned up {expired_count} expired prime users\")\n            return expired_count\n            \n        except Exception as e:\n            logger.error(f\"Error cleaning up expired prime: {e}\")\n            return 0","size_bytes":12910},"utils/database.py":{"content":"\"\"\"\nDatabase module for Telegram YouTube Downloader Bot\nHandles users, prime subscriptions, and usage tracking\n\"\"\"\n\nimport aiosqlite\nimport logging\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any, List\n\nlogger = logging.getLogger(__name__)\n\nclass Database:\n    def __init__(self, db_path: str = \"db/bot_database.db\"):\n        \"\"\"Initialize database connection\"\"\"\n        self.db_path = db_path\n        # Ensure db directory exists\n        os.makedirs(os.path.dirname(db_path), exist_ok=True)\n    \n    async def initialize(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            # Users table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    user_id INTEGER PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    is_prime BOOLEAN DEFAULT FALSE,\n                    prime_expiry TIMESTAMP NULL,\n                    downloads_today INTEGER DEFAULT 0,\n                    downloads_this_hour INTEGER DEFAULT 0,\n                    last_download TIMESTAMP NULL,\n                    hour_reset_time TIMESTAMP NULL,\n                    cooldown_until TIMESTAMP NULL,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    state TEXT DEFAULT '',\n                    temp_data TEXT DEFAULT '{}'\n                )\n            \"\"\")\n            \n            # Download logs table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS download_logs (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    url TEXT,\n                    download_type TEXT,\n                    quality TEXT,\n                    file_size INTEGER,\n                    success BOOLEAN,\n                    error_message TEXT,\n                    download_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    FOREIGN KEY (user_id) REFERENCES users (user_id)\n                )\n            \"\"\")\n            \n            # Admin settings table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS admin_settings (\n                    key TEXT PRIMARY KEY,\n                    value TEXT,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Bot statistics table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS bot_stats (\n                    date TEXT PRIMARY KEY,\n                    total_users INTEGER DEFAULT 0,\n                    new_users INTEGER DEFAULT 0,\n                    total_downloads INTEGER DEFAULT 0,\n                    video_downloads INTEGER DEFAULT 0,\n                    audio_downloads INTEGER DEFAULT 0,\n                    prime_users INTEGER DEFAULT 0,\n                    failed_downloads INTEGER DEFAULT 0\n                )\n            \"\"\")\n            \n            await db.commit()\n            logger.info(\"Database initialized successfully\")\n    \n    async def get_user(self, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get user information by ID\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            db.row_factory = aiosqlite.Row\n            async with db.execute(\"SELECT * FROM users WHERE user_id = ?\", (user_id,)) as cursor:\n                row = await cursor.fetchone()\n                return dict(row) if row else None\n    \n    async def create_user(self, user_id: int, username: str = None, first_name: str = None, last_name: str = None) -> bool:\n        \"\"\"Create a new user\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    INSERT OR REPLACE INTO users \n                    (user_id, username, first_name, last_name, created_at, last_active) \n                    VALUES (?, ?, ?, ?, ?, ?)\n                \"\"\", (user_id, username, first_name, last_name, datetime.now(), datetime.now()))\n                await db.commit()\n                logger.info(f\"User {user_id} created/updated\")\n                return True\n        except Exception as e:\n            logger.error(f\"Error creating user {user_id}: {e}\")\n            return False\n    \n    async def update_user_activity(self, user_id: int):\n        \"\"\"Update user's last activity timestamp\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\n                    \"UPDATE users SET last_active = ? WHERE user_id = ?\",\n                    (datetime.now(), user_id)\n                )\n                await db.commit()\n        except Exception as e:\n            logger.error(f\"Error updating user activity {user_id}: {e}\")\n    \n    async def set_prime_status(self, user_id: int, is_prime: bool, expiry_days: int = None) -> bool:\n        \"\"\"Set user's prime status\"\"\"\n        try:\n            expiry_date = None\n            if is_prime and expiry_days:\n                expiry_date = datetime.now() + timedelta(days=expiry_days)\n            \n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    UPDATE users \n                    SET is_prime = ?, prime_expiry = ? \n                    WHERE user_id = ?\n                \"\"\", (is_prime, expiry_date, user_id))\n                await db.commit()\n                \n            logger.info(f\"Prime status updated for user {user_id}: {is_prime}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error setting prime status for user {user_id}: {e}\")\n            return False\n    \n    async def check_prime_status(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Check if user's prime status is valid\"\"\"\n        user = await self.get_user(user_id)\n        if not user:\n            return {\"is_prime\": False, \"expired\": True}\n        \n        is_prime = user.get('is_prime', False)\n        prime_expiry = user.get('prime_expiry')\n        \n        if not is_prime:\n            return {\"is_prime\": False, \"expired\": False}\n        \n        # Check if prime has expired\n        if prime_expiry:\n            expiry_dt = datetime.fromisoformat(prime_expiry.replace('Z', '+00:00')) if isinstance(prime_expiry, str) else prime_expiry\n            if datetime.now() > expiry_dt:\n                # Expire the user\n                await self.set_prime_status(user_id, False)\n                return {\"is_prime\": False, \"expired\": True, \"expiry_date\": expiry_dt}\n        \n        return {\n            \"is_prime\": True, \n            \"expired\": False, \n            \"expiry_date\": prime_expiry\n        }\n    \n    async def get_download_stats(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get user's download statistics and limits\"\"\"\n        user = await self.get_user(user_id)\n        if not user:\n            return {\n                \"downloads_this_hour\": 0,\n                \"can_download\": False,\n                \"reset_time\": None,\n                \"in_cooldown\": False\n            }\n        \n        now = datetime.now()\n        downloads_this_hour = user.get('downloads_this_hour', 0)\n        hour_reset_time = user.get('hour_reset_time')\n        cooldown_until = user.get('cooldown_until')\n        \n        # Parse datetime strings\n        if isinstance(hour_reset_time, str):\n            hour_reset_time = datetime.fromisoformat(hour_reset_time.replace('Z', '+00:00'))\n        if isinstance(cooldown_until, str):\n            cooldown_until = datetime.fromisoformat(cooldown_until.replace('Z', '+00:00'))\n        \n        # Check if hour has reset\n        if not hour_reset_time or now >= hour_reset_time:\n            await self.reset_hourly_downloads(user_id)\n            downloads_this_hour = 0\n            hour_reset_time = now + timedelta(hours=1)\n        \n        # Check cooldown\n        in_cooldown = cooldown_until and now < cooldown_until\n        \n        # Check if user can download\n        prime_status = await self.check_prime_status(user_id)\n        can_download = prime_status['is_prime'] or (downloads_this_hour < 15 and not in_cooldown)\n        \n        return {\n            \"downloads_this_hour\": downloads_this_hour,\n            \"can_download\": can_download,\n            \"reset_time\": hour_reset_time,\n            \"in_cooldown\": in_cooldown,\n            \"cooldown_until\": cooldown_until\n        }\n    \n    async def increment_download_count(self, user_id: int) -> bool:\n        \"\"\"Increment user's download count and set cooldown if needed\"\"\"\n        try:\n            user = await self.get_user(user_id)\n            if not user:\n                return False\n            \n            downloads_this_hour = user.get('downloads_this_hour', 0) + 1\n            now = datetime.now()\n            \n            # Set cooldown after 15 downloads for non-prime users\n            cooldown_until = None\n            prime_status = await self.check_prime_status(user_id)\n            if not prime_status['is_prime'] and downloads_this_hour >= 15:\n                cooldown_until = now + timedelta(minutes=30)\n            \n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    UPDATE users \n                    SET downloads_this_hour = ?, \n                        downloads_today = downloads_today + 1,\n                        last_download = ?,\n                        cooldown_until = ?\n                    WHERE user_id = ?\n                \"\"\", (downloads_this_hour, now, cooldown_until, user_id))\n                await db.commit()\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error incrementing download count for user {user_id}: {e}\")\n            return False\n    \n    async def reset_hourly_downloads(self, user_id: int) -> bool:\n        \"\"\"Reset user's hourly download count\"\"\"\n        try:\n            now = datetime.now()\n            next_reset = now + timedelta(hours=1)\n            \n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    UPDATE users \n                    SET downloads_this_hour = 0, \n                        hour_reset_time = ?,\n                        cooldown_until = NULL\n                    WHERE user_id = ?\n                \"\"\", (next_reset, user_id))\n                await db.commit()\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error resetting hourly downloads for user {user_id}: {e}\")\n            return False\n    \n    async def log_download(self, user_id: int, url: str, download_type: str, quality: str, \n                          file_size: int = 0, success: bool = True, error_message: str = None) -> bool:\n        \"\"\"Log a download attempt\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    INSERT INTO download_logs \n                    (user_id, url, download_type, quality, file_size, success, error_message)\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\n                \"\"\", (user_id, url, download_type, quality, file_size, success, error_message))\n                await db.commit()\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error logging download: {e}\")\n            return False\n    \n    async def get_bot_stats(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive bot statistics\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            stats = {}\n            \n            # Total users\n            async with db.execute(\"SELECT COUNT(*) as count FROM users\") as cursor:\n                row = await cursor.fetchone()\n                stats['total_users'] = row[0] if row else 0\n            \n            # Prime users\n            async with db.execute(\"SELECT COUNT(*) as count FROM users WHERE is_prime = TRUE\") as cursor:\n                row = await cursor.fetchone()\n                stats['prime_users'] = row[0] if row else 0\n            \n            # Downloads today\n            today = datetime.now().date()\n            async with db.execute(\"\"\"\n                SELECT COUNT(*) as count FROM download_logs \n                WHERE date(download_time) = ?\n            \"\"\", (today,)) as cursor:\n                row = await cursor.fetchone()\n                stats['downloads_today'] = row[0] if row else 0\n            \n            # Total downloads\n            async with db.execute(\"SELECT COUNT(*) as count FROM download_logs WHERE success = TRUE\") as cursor:\n                row = await cursor.fetchone()\n                stats['total_downloads'] = row[0] if row else 0\n            \n            # Failed downloads\n            async with db.execute(\"SELECT COUNT(*) as count FROM download_logs WHERE success = FALSE\") as cursor:\n                row = await cursor.fetchone()\n                stats['failed_downloads'] = row[0] if row else 0\n            \n            # Video vs Audio downloads\n            async with db.execute(\"\"\"\n                SELECT download_type, COUNT(*) as count \n                FROM download_logs \n                WHERE success = TRUE \n                GROUP BY download_type\n            \"\"\") as cursor:\n                rows = await cursor.fetchall()\n                stats['video_downloads'] = 0\n                stats['audio_downloads'] = 0\n                for row in rows:\n                    if 'video' in row[0].lower():\n                        stats['video_downloads'] = row[1]\n                    elif 'audio' in row[0].lower():\n                        stats['audio_downloads'] = row[1]\n            \n            # Active users (last 24 hours)\n            yesterday = datetime.now() - timedelta(days=1)\n            async with db.execute(\"\"\"\n                SELECT COUNT(*) as count FROM users \n                WHERE last_active > ?\n            \"\"\", (yesterday,)) as cursor:\n                row = await cursor.fetchone()\n                stats['active_users_24h'] = row[0] if row else 0\n            \n            return stats\n    \n    async def get_all_user_ids(self) -> List[int]:\n        \"\"\"Get all user IDs for broadcasting\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\"SELECT user_id FROM users\") as cursor:\n                rows = await cursor.fetchall()\n                return [row[0] for row in rows]\n    \n    async def set_user_state(self, user_id: int, state: str) -> bool:\n        \"\"\"Set user's current state\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\n                    \"UPDATE users SET state = ? WHERE user_id = ?\",\n                    (state, user_id)\n                )\n                await db.commit()\n            return True\n        except Exception as e:\n            logger.error(f\"Error setting user state {user_id}: {e}\")\n            return False\n    \n    async def get_user_state(self, user_id: int) -> str:\n        \"\"\"Get user's current state\"\"\"\n        user = await self.get_user(user_id)\n        return user.get('state', '') if user else ''\n    \n    async def set_user_temp_data(self, user_id: int, key: str, value: str) -> bool:\n        \"\"\"Set temporary user data\"\"\"\n        try:\n            import json\n            user = await self.get_user(user_id)\n            if not user:\n                return False\n            \n            temp_data = json.loads(user.get('temp_data', '{}'))\n            temp_data[key] = value\n            \n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\n                    \"UPDATE users SET temp_data = ? WHERE user_id = ?\",\n                    (json.dumps(temp_data), user_id)\n                )\n                await db.commit()\n            return True\n        except Exception as e:\n            logger.error(f\"Error setting user temp data {user_id}: {e}\")\n            return False\n    \n    async def get_user_temp_data(self, user_id: int, key: str) -> Optional[str]:\n        \"\"\"Get temporary user data\"\"\"\n        try:\n            import json\n            user = await self.get_user(user_id)\n            if not user:\n                return None\n            \n            temp_data = json.loads(user.get('temp_data', '{}'))\n            return temp_data.get(key)\n        except Exception as e:\n            logger.error(f\"Error getting user temp data {user_id}: {e}\")\n            return None\n    \n    async def clear_user_temp_data(self, user_id: int) -> bool:\n        \"\"\"Clear all temporary user data\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\n                    \"UPDATE users SET temp_data = '{}' WHERE user_id = ?\",\n                    (user_id,)\n                )\n                await db.commit()\n            return True\n        except Exception as e:\n            logger.error(f\"Error clearing user temp data {user_id}: {e}\")\n            return False","size_bytes":17139},"utils/download_manager.py":{"content":"\"\"\"\nDownload manager for YouTube content using yt-dlp\nHandles video and audio downloads with quality options\n\"\"\"\n\nimport os\nimport asyncio\nimport logging\nimport tempfile\nfrom typing import Dict, Any\nimport yt_dlp\nfrom aiogram.types import BufferedInputFile\n\nlogger = logging.getLogger(__name__)\n\nclass DownloadManager:\n    def __init__(self):\n        \"\"\"Initialize download manager\"\"\"\n        self.temp_dir = \"temp\"\n        os.makedirs(self.temp_dir, exist_ok=True)\n        \n        # yt-dlp options\n        self.base_opts = {\n            'quiet': True,\n            'no_warnings': True,\n            'extractaudio': False,\n            'format': 'best',\n            'outtmpl': os.path.join(self.temp_dir, '%(title)s.%(ext)s'),\n            'cookiefile': 'cookies/cookies.txt' if os.path.exists('cookies/cookies.txt') else None,\n        }\n    \n    async def download_content(self, url: str, quality: str, user_id: int) -> Dict[str, Any]:\n        \"\"\"Download video or audio content\"\"\"\n        try:\n            # Determine download type and options based on quality selection\n            opts = self.base_opts.copy()\n            \n            if quality.startswith('quality_'):\n                # Video download\n                return await self._download_video(url, quality, user_id, opts)\n            elif quality.startswith('audio_'):\n                # Audio download\n                return await self._download_audio(url, quality, user_id, opts)\n            else:\n                return {\n                    'success': False,\n                    'error': 'Invalid quality selection'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Download error for user {user_id}: {e}\")\n            return {\n                'success': False,\n                'error': f'Download failed: {str(e)}'\n            }\n    \n    async def _download_video(self, url: str, quality: str, user_id: int, opts: dict) -> Dict[str, Any]:\n        \"\"\"Download video content\"\"\"\n        try:\n            # Set video format based on quality\n            quality_map = {\n                'quality_360p': 'best[height<=360]',\n                'quality_480p': 'best[height<=480]',\n                'quality_720p': 'best[height<=720]',\n                'quality_1080p': 'best[height<=1080]'\n            }\n            \n            opts['format'] = quality_map.get(quality, 'best[height<=480]')\n            opts['outtmpl'] = os.path.join(self.temp_dir, f'video_{user_id}_%(title)s.%(ext)s')\n            \n            # Download video\n            with yt_dlp.YoutubeDL(opts) as ydl:\n                # Extract info first\n                info = await asyncio.to_thread(ydl.extract_info, url, download=False)\n                title = info.get('title', 'Unknown')\n                duration = info.get('duration', 0)\n                \n                # Check file size (approximate)\n                if duration > 3600:  # More than 1 hour\n                    return {\n                        'success': False,\n                        'error': 'Video too long (max 1 hour allowed)'\n                    }\n                \n                # Download the video\n                info = await asyncio.to_thread(ydl.extract_info, url, download=True)\n                filename = ydl.prepare_filename(info)\n                \n                if not os.path.exists(filename):\n                    return {\n                        'success': False,\n                        'error': 'Download file not found'\n                    }\n                \n                # Check file size\n                file_size = os.path.getsize(filename)\n                if file_size > 50 * 1024 * 1024:  # 50MB limit\n                    os.remove(filename)\n                    return {\n                        'success': False,\n                        'error': 'File too large (max 50MB)'\n                    }\n                \n                # Read file and create BufferedInputFile\n                with open(filename, 'rb') as f:\n                    file_content = f.read()\n                \n                # Clean up temp file\n                os.remove(filename)\n                \n                # Get quality info\n                quality_info = quality.replace('quality_', '').upper()\n                \n                return {\n                    'success': True,\n                    'type': 'video',\n                    'file': BufferedInputFile(file_content, filename=f\"{title}.mp4\"),\n                    'quality': quality_info,\n                    'title': title,\n                    'file_size': file_size\n                }\n                \n        except Exception as e:\n            logger.error(f\"Video download error: {e}\")\n            return {\n                'success': False,\n                'error': f'Video download failed: {str(e)}'\n            }\n    \n    async def _download_audio(self, url: str, quality: str, user_id: int, opts: dict) -> Dict[str, Any]:\n        \"\"\"Download audio content\"\"\"\n        try:\n            # Set audio format options\n            opts['extractaudio'] = True\n            opts['audioformat'] = 'mp3'\n            opts['outtmpl'] = os.path.join(self.temp_dir, f'audio_{user_id}_%(title)s.%(ext)s')\n            \n            if quality == 'audio_hq':\n                opts['audioquality'] = '0'  # Best quality\n            else:\n                opts['audioquality'] = '5'  # Standard quality\n            \n            # Download audio\n            with yt_dlp.YoutubeDL(opts) as ydl:\n                # Extract info first\n                info = await asyncio.to_thread(ydl.extract_info, url, download=False)\n                title = info.get('title', 'Unknown')\n                duration = info.get('duration', 0)\n                \n                # Check duration\n                if duration > 3600:  # More than 1 hour\n                    return {\n                        'success': False,\n                        'error': 'Audio too long (max 1 hour allowed)'\n                    }\n                \n                # Download the audio\n                info = await asyncio.to_thread(ydl.extract_info, url, download=True)\n                \n                # Find the actual filename (yt-dlp may change extension)\n                base_filename = ydl.prepare_filename(info)\n                possible_files = [\n                    base_filename.rsplit('.', 1)[0] + '.mp3',\n                    base_filename.rsplit('.', 1)[0] + '.m4a',\n                    base_filename.rsplit('.', 1)[0] + '.webm',\n                    base_filename\n                ]\n                \n                filename = None\n                for possible_file in possible_files:\n                    if os.path.exists(possible_file):\n                        filename = possible_file\n                        break\n                \n                if not filename or not os.path.exists(filename):\n                    return {\n                        'success': False,\n                        'error': 'Audio file not found after download'\n                    }\n                \n                # Check file size\n                file_size = os.path.getsize(filename)\n                if file_size > 50 * 1024 * 1024:  # 50MB limit\n                    os.remove(filename)\n                    return {\n                        'success': False,\n                        'error': 'File too large (max 50MB)'\n                    }\n                \n                # Read file and create BufferedInputFile\n                with open(filename, 'rb') as f:\n                    file_content = f.read()\n                \n                # Clean up temp file\n                os.remove(filename)\n                \n                # Get quality info\n                quality_info = \"High Quality\" if quality == 'audio_hq' else \"Standard\"\n                \n                return {\n                    'success': True,\n                    'type': 'audio',\n                    'file': BufferedInputFile(file_content, filename=f\"{title}.mp3\"),\n                    'quality': quality_info,\n                    'title': title,\n                    'file_size': file_size\n                }\n                \n        except Exception as e:\n            logger.error(f\"Audio download error: {e}\")\n            return {\n                'success': False,\n                'error': f'Audio download failed: {str(e)}'\n            }\n    \n    async def get_video_info(self, url: str) -> Dict[str, Any]:\n        \"\"\"Get video information without downloading\"\"\"\n        try:\n            opts = {\n                'quiet': True,\n                'no_warnings': True,\n            }\n            \n            with yt_dlp.YoutubeDL(opts) as ydl:\n                info = await asyncio.to_thread(ydl.extract_info, url, download=False)\n                \n                return {\n                    'success': True,\n                    'title': info.get('title', 'Unknown'),\n                    'duration': info.get('duration', 0),\n                    'uploader': info.get('uploader', 'Unknown'),\n                    'view_count': info.get('view_count', 0),\n                    'upload_date': info.get('upload_date', ''),\n                    'description': info.get('description', '')[:200] + '...' if info.get('description') else ''\n                }\n        except Exception as e:\n            logger.error(f\"Error getting video info: {e}\")\n            return {\n                'success': False,\n                'error': f'Could not get video info: {str(e)}'\n            }\n    \n    def cleanup_temp_files(self):\n        \"\"\"Clean up temporary files\"\"\"\n        try:\n            for filename in os.listdir(self.temp_dir):\n                file_path = os.path.join(self.temp_dir, filename)\n                if os.path.isfile(file_path):\n                    # Remove files older than 1 hour\n                    file_age = os.path.getmtime(file_path)\n                    if (asyncio.get_event_loop().time() - file_age) > 3600:\n                        os.remove(file_path)\n                        logger.info(f\"Cleaned up temp file: {filename}\")\n        except Exception as e:\n            logger.error(f\"Error cleaning temp files: {e}\")\n    \n    async def is_valid_youtube_url(self, url: str) -> bool:\n        \"\"\"Check if URL is a valid YouTube URL\"\"\"\n        youtube_domains = [\n            'youtube.com', 'youtu.be', 'www.youtube.com', 'm.youtube.com'\n        ]\n        \n        try:\n            from urllib.parse import urlparse\n            parsed = urlparse(url)\n            return parsed.netloc in youtube_domains\n        except:\n            return False","size_bytes":10545},"utils/user_manager.py":{"content":"\"\"\"\nUser manager for handling user states, limits, and permissions\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nfrom .database import Database\n\nlogger = logging.getLogger(__name__)\n\nclass UserManager:\n    def __init__(self, database: Database):\n        \"\"\"Initialize user manager with database\"\"\"\n        self.db = database\n    \n    async def initialize_user(self, user_id: int, username: str = None) -> bool:\n        \"\"\"Initialize or update user in database\"\"\"\n        try:\n            # Check if user exists\n            user = await self.db.get_user(user_id)\n            if not user:\n                # Create new user\n                await self.db.create_user(user_id, username)\n                logger.info(f\"New user initialized: {user_id}\")\n            else:\n                # Update activity\n                await self.db.update_user_activity(user_id)\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error initializing user {user_id}: {e}\")\n            return False\n    \n    async def get_user_status(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get comprehensive user status including limits and prime status\"\"\"\n        try:\n            # Ensure user exists\n            await self.initialize_user(user_id)\n            \n            # Get prime status\n            prime_status = await self.db.check_prime_status(user_id)\n            \n            # Get download stats\n            download_stats = await self.db.get_download_stats(user_id)\n            \n            # Calculate remaining downloads\n            downloads_remaining = 15 - download_stats['downloads_this_hour'] if not prime_status['is_prime'] else float('inf')\n            \n            # Format reset time\n            reset_time = download_stats['reset_time']\n            reset_time_str = reset_time.strftime('%H:%M:%S') if reset_time else 'Unknown'\n            \n            # Format prime expiry\n            prime_expiry_str = None\n            if prime_status.get('expiry_date'):\n                expiry_date = prime_status['expiry_date']\n                if isinstance(expiry_date, str):\n                    expiry_date = datetime.fromisoformat(expiry_date.replace('Z', '+00:00'))\n                prime_expiry_str = expiry_date.strftime('%Y-%m-%d %H:%M:%S')\n            \n            return {\n                'is_prime': prime_status['is_prime'],\n                'prime_expiry': prime_expiry_str,\n                'downloads_this_hour': download_stats['downloads_this_hour'],\n                'downloads_remaining': downloads_remaining,\n                'can_download': download_stats['can_download'],\n                'reset_time': reset_time_str,\n                'in_cooldown': download_stats['in_cooldown'],\n                'cooldown_until': download_stats.get('cooldown_until')\n            }\n        except Exception as e:\n            logger.error(f\"Error getting user status {user_id}: {e}\")\n            return {\n                'is_prime': False,\n                'prime_expiry': None,\n                'downloads_this_hour': 0,\n                'downloads_remaining': 0,\n                'can_download': False,\n                'reset_time': 'Error',\n                'in_cooldown': True,\n                'cooldown_until': None\n            }\n    \n    async def update_usage(self, user_id: int) -> bool:\n        \"\"\"Update user's download usage\"\"\"\n        try:\n            success = await self.db.increment_download_count(user_id)\n            if success:\n                logger.info(f\"Updated usage for user {user_id}\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error updating usage for user {user_id}: {e}\")\n            return False\n    \n    async def can_user_download(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Check if user can download and why/why not\"\"\"\n        try:\n            status = await self.get_user_status(user_id)\n            \n            if status['is_prime']:\n                return {\n                    'can_download': True,\n                    'reason': 'Prime user - unlimited downloads'\n                }\n            \n            if status['in_cooldown']:\n                return {\n                    'can_download': False,\n                    'reason': f\"In cooldown period. Try again after {status['cooldown_until']}\"\n                }\n            \n            if status['downloads_this_hour'] >= 15:\n                return {\n                    'can_download': False,\n                    'reason': f\"Download limit reached (15/hour). Resets at {status['reset_time']}\"\n                }\n            \n            return {\n                'can_download': True,\n                'reason': f\"Downloads remaining: {status['downloads_remaining']}/15\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error checking user download permission {user_id}: {e}\")\n            return {\n                'can_download': False,\n                'reason': 'Error checking permissions'\n            }\n    \n    async def get_downloads_remaining(self, user_id: int) -> int:\n        \"\"\"Get number of downloads remaining for user\"\"\"\n        try:\n            status = await self.get_user_status(user_id)\n            if status['is_prime']:\n                return float('inf')\n            return max(0, 15 - status['downloads_this_hour'])\n        except Exception as e:\n            logger.error(f\"Error getting downloads remaining for user {user_id}: {e}\")\n            return 0\n    \n    async def set_user_state(self, user_id: int, state: str) -> bool:\n        \"\"\"Set user's current interaction state\"\"\"\n        try:\n            return await self.db.set_user_state(user_id, state)\n        except Exception as e:\n            logger.error(f\"Error setting user state {user_id}: {e}\")\n            return False\n    \n    async def get_user_state(self, user_id: int) -> str:\n        \"\"\"Get user's current interaction state\"\"\"\n        try:\n            return await self.db.get_user_state(user_id)\n        except Exception as e:\n            logger.error(f\"Error getting user state {user_id}: {e}\")\n            return \"\"\n    \n    async def clear_user_state(self, user_id: int) -> bool:\n        \"\"\"Clear user's current interaction state\"\"\"\n        try:\n            return await self.db.set_user_state(user_id, \"\")\n        except Exception as e:\n            logger.error(f\"Error clearing user state {user_id}: {e}\")\n            return False\n    \n    async def set_user_data(self, user_id: int, key: str, value: str) -> bool:\n        \"\"\"Set temporary user data\"\"\"\n        try:\n            return await self.db.set_user_temp_data(user_id, key, value)\n        except Exception as e:\n            logger.error(f\"Error setting user data {user_id}: {e}\")\n            return False\n    \n    async def get_user_data(self, user_id: int, key: str) -> Optional[str]:\n        \"\"\"Get temporary user data\"\"\"\n        try:\n            return await self.db.get_user_temp_data(user_id, key)\n        except Exception as e:\n            logger.error(f\"Error getting user data {user_id}: {e}\")\n            return None\n    \n    async def clear_user_data(self, user_id: int) -> bool:\n        \"\"\"Clear all temporary user data\"\"\"\n        try:\n            return await self.db.clear_user_temp_data(user_id)\n        except Exception as e:\n            logger.error(f\"Error clearing user data {user_id}: {e}\")\n            return False\n    \n    async def grant_prime(self, user_id: int, days: int = None) -> bool:\n        \"\"\"Grant prime status to user\"\"\"\n        try:\n            success = await self.db.set_prime_status(user_id, True, days)\n            if success:\n                logger.info(f\"Prime granted to user {user_id} for {days} days\" if days else f\"Prime granted to user {user_id} (permanent)\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error granting prime to user {user_id}: {e}\")\n            return False\n    \n    async def revoke_prime(self, user_id: int) -> bool:\n        \"\"\"Revoke prime status from user\"\"\"\n        try:\n            success = await self.db.set_prime_status(user_id, False)\n            if success:\n                logger.info(f\"Prime revoked from user {user_id}\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error revoking prime from user {user_id}: {e}\")\n            return False\n    \n    async def get_user_info(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get detailed user information\"\"\"\n        try:\n            user = await self.db.get_user(user_id)\n            if not user:\n                return None\n            \n            status = await self.get_user_status(user_id)\n            \n            return {\n                'user_id': user['user_id'],\n                'username': user.get('username', 'Unknown'),\n                'first_name': user.get('first_name', ''),\n                'last_name': user.get('last_name', ''),\n                'created_at': user.get('created_at', ''),\n                'last_active': user.get('last_active', ''),\n                'is_prime': status['is_prime'],\n                'prime_expiry': status['prime_expiry'],\n                'downloads_this_hour': status['downloads_this_hour'],\n                'total_downloads': user.get('downloads_today', 0)\n            }\n        except Exception as e:\n            logger.error(f\"Error getting user info {user_id}: {e}\")\n            return None","size_bytes":9450},"utils/admin_panel_simple.py":{"content":"\"\"\"\nSimple Admin Panel for Telegram YouTube Downloader Bot\n\"\"\"\n\nimport logging\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\nfrom aiogram import Bot\nfrom aiogram.types import Message\n\nlogger = logging.getLogger(__name__)\n\nclass ProfessionalAdminPanel:\n    def __init__(self, database, bot: Bot, admin_id: int, analytics_enabled: bool = True):\n        \"\"\"Initialize admin panel\"\"\"\n        self.db = database\n        self.bot = bot\n        self.admin_id = admin_id\n        self.analytics_enabled = analytics_enabled\n    \n    async def handle_set_prime(self, message: Message):\n        \"\"\"Handle set prime command\"\"\"\n        try:\n            parts = message.text.split()\n            if len(parts) < 3:\n                await message.reply(\"Usage: /setprime [user_id] [days] [reason]\")\n                return\n            \n            user_id = int(parts[1])\n            days = int(parts[2])\n            reason = \" \".join(parts[3:]) if len(parts) > 3 else \"Admin grant\"\n            \n            # Calculate expiry date\n            expiry_date = datetime.now() + timedelta(days=days)\n            expiry_str = expiry_date.isoformat()\n            \n            # Set prime status\n            await self.db.set_prime_status(user_id, True, expiry_str)\n            \n            # Send confirmation\n            await message.reply(f\"✅ Premium access granted to user {user_id} for {days} days.\\nExpiry: {expiry_date.strftime('%Y-%m-%d %H:%M')}\\nReason: {reason}\")\n            \n            # Notify user\n            try:\n                await self.bot.send_message(\n                    user_id,\n                    f\"🎉 <b>Premium Access Granted!</b>\\n\\n👑 You now have premium access for {days} days!\\n\\n<b>Premium Benefits:</b>\\n• Unlimited downloads\\n• HD quality (720p, 1080p)\\n• High-quality audio\\n• No cooldowns\\n\\n📅 Expires: {expiry_date.strftime('%Y-%m-%d %H:%M')}\"\n                )\n            except:\n                pass  # User might have blocked bot\n                \n        except ValueError:\n            await message.reply(\"❌ Invalid user ID or days value. Please use numbers only.\")\n        except Exception as e:\n            logger.error(f\"Error setting prime: {e}\")\n            await message.reply(f\"❌ Error setting premium access: {e}\")\n    \n    async def handle_remove_prime(self, message: Message):\n        \"\"\"Handle remove prime command\"\"\"\n        try:\n            parts = message.text.split()\n            if len(parts) < 2:\n                await message.reply(\"Usage: /removeprime [user_id] [reason]\")\n                return\n            \n            user_id = int(parts[1])\n            reason = \" \".join(parts[2:]) if len(parts) > 2 else \"Admin removal\"\n            \n            # Remove prime status\n            await self.db.set_prime_status(user_id, False, None)\n            \n            # Send confirmation\n            await message.reply(f\"✅ Premium access removed from user {user_id}.\\nReason: {reason}\")\n            \n            # Notify user\n            try:\n                await self.bot.send_message(\n                    user_id,\n                    f\"📢 <b>Premium Access Update</b>\\n\\nYour premium access has been removed.\\n\\nYou can still use the bot with standard features:\\n• 15 downloads per hour\\n• 360p and 480p quality\\n\\nContact @chhinhlong for premium upgrade.\"\n                )\n            except:\n                pass  # User might have blocked bot\n                \n        except ValueError:\n            await message.reply(\"❌ Invalid user ID. Please use numbers only.\")\n        except Exception as e:\n            logger.error(f\"Error removing prime: {e}\")\n            await message.reply(f\"❌ Error removing premium access: {e}\")\n    \n    async def handle_stats(self, message: Message):\n        \"\"\"Handle stats command\"\"\"\n        try:\n            stats = await self.db.get_stats()\n            \n            stats_text = f\"\"\"\n📊 <b>Bot Statistics</b>\n\n👥 <b>Users:</b>\n• Total Users: {stats['total_users']}\n• Premium Users: {stats['prime_users']}\n• Active (24h): {stats['active_24h']}\n\n📁 <b>Downloads:</b>\n• Total Downloads: {stats['total_downloads']}\n• Successful: {stats['successful_downloads']}\n• Success Rate: {stats['success_rate']}%\n\n📅 <b>Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n            \"\"\"\n            \n            await message.reply(stats_text)\n            \n        except Exception as e:\n            logger.error(f\"Error getting stats: {e}\")\n            await message.reply(f\"❌ Error getting statistics: {e}\")\n    \n    async def handle_broadcast(self, message: Message):\n        \"\"\"Handle broadcast command\"\"\"\n        try:\n            parts = message.text.split(maxsplit=1)\n            if len(parts) < 2:\n                await message.reply(\"Usage: /broadcast [message]\")\n                return\n            \n            broadcast_message = parts[1]\n            users = await self.db.get_all_users()\n            \n            if not users:\n                await message.reply(\"❌ No users found to broadcast to.\")\n                return\n            \n            # Send initial status\n            status_msg = await message.reply(f\"📢 Starting broadcast to {len(users)} users...\")\n            \n            sent_count = 0\n            failed_count = 0\n            \n            for user_id in users:\n                try:\n                    await self.bot.send_message(user_id, broadcast_message)\n                    sent_count += 1\n                    \n                    # Update status every 10 messages\n                    if sent_count % 10 == 0:\n                        await status_msg.edit_text(f\"📢 Broadcast progress: {sent_count}/{len(users)} sent...\")\n                    \n                    # Small delay to avoid rate limits\n                    await asyncio.sleep(0.1)\n                    \n                except Exception as e:\n                    failed_count += 1\n                    logger.warning(f\"Failed to send broadcast to user {user_id}: {e}\")\n            \n            # Final status\n            await status_msg.edit_text(\n                f\"✅ <b>Broadcast Complete!</b>\\n\\n\"\n                f\"📊 <b>Results:</b>\\n\"\n                f\"• Sent: {sent_count}\\n\"\n                f\"• Failed: {failed_count}\\n\"\n                f\"• Total: {len(users)}\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error broadcasting: {e}\")\n            await message.reply(f\"❌ Error broadcasting message: {e}\")","size_bytes":6535},"utils/analytics_simple.py":{"content":"\"\"\"\nSimple Analytics module for basic monitoring\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\nclass AnalyticsManager:\n    def __init__(self, database):\n        \"\"\"Initialize analytics manager\"\"\"\n        self.db = database\n        self.counters = defaultdict(int)\n    \n    async def track_user_event(self, user_id: int, event_type: str, data: Dict[str, Any] = None):\n        \"\"\"Track user event\"\"\"\n        try:\n            self.counters[f\"event_{event_type}\"] += 1\n            self.counters[f\"user_{user_id}_events\"] += 1\n            logger.debug(f\"Tracked event {event_type} for user {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error tracking event: {e}\")\n    \n    async def get_analytics_summary(self) -> Dict[str, Any]:\n        \"\"\"Get analytics summary\"\"\"\n        try:\n            stats = await self.db.get_stats()\n            return {\n                'timestamp': datetime.now().isoformat(),\n                'database_stats': stats,\n                'event_counters': dict(self.counters)\n            }\n        except Exception as e:\n            logger.error(f\"Error getting analytics: {e}\")\n            return {'error': str(e)}","size_bytes":1264},"utils/database_simple.py":{"content":"\"\"\"\nSimple Database module for Telegram YouTube Downloader Bot\n\"\"\"\n\nimport aiosqlite\nimport logging\nimport os\nimport time\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\n\nlogger = logging.getLogger(__name__)\n\nclass DatabasePro:\n    def __init__(self, db_path: str = \"db/bot_database.db\", pool_size: int = 10, cache_size: int = 1000):\n        \"\"\"Initialize database\"\"\"\n        self.db_path = db_path\n        self.pool_size = pool_size\n        self.cache_size = cache_size\n        \n        # Ensure db directory exists\n        os.makedirs(os.path.dirname(db_path), exist_ok=True)\n    \n    async def initialize(self):\n        \"\"\"Initialize database tables\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                # Create users table\n                await db.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS users (\n                        user_id INTEGER PRIMARY KEY,\n                        username TEXT,\n                        is_prime BOOLEAN DEFAULT FALSE,\n                        prime_expiry TEXT,\n                        downloads_count INTEGER DEFAULT 0,\n                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n                        last_seen TEXT DEFAULT CURRENT_TIMESTAMP\n                    )\n                \"\"\")\n                \n                # Create downloads table\n                await db.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS downloads (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        user_id INTEGER,\n                        url TEXT,\n                        quality TEXT,\n                        success BOOLEAN,\n                        error_message TEXT,\n                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (user_id)\n                    )\n                \"\"\")\n                \n                # Create admin_actions table\n                await db.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS admin_actions (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        admin_id INTEGER,\n                        action TEXT,\n                        target_user_id INTEGER,\n                        details TEXT,\n                        created_at TEXT DEFAULT CURRENT_TIMESTAMP\n                    )\n                \"\"\")\n                \n                await db.commit()\n                logger.info(\"Database initialized successfully\")\n                \n        except Exception as e:\n            logger.error(f\"Database initialization error: {e}\")\n    \n    async def add_user(self, user_id: int, username: str):\n        \"\"\"Add or update user\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    INSERT OR REPLACE INTO users (user_id, username)\n                    VALUES (?, ?)\n                \"\"\", (user_id, username))\n                await db.commit()\n        except Exception as e:\n            logger.error(f\"Error adding user {user_id}: {e}\")\n    \n    async def get_user(self, user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get user data\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                db.row_factory = aiosqlite.Row\n                async with db.execute(\"SELECT * FROM users WHERE user_id = ?\", (user_id,)) as cursor:\n                    row = await cursor.fetchone()\n                    if row:\n                        return dict(row)\n                    return None\n        except Exception as e:\n            logger.error(f\"Error getting user {user_id}: {e}\")\n            return None\n    \n    async def set_prime_status(self, user_id: int, is_prime: bool, expiry: Optional[str] = None):\n        \"\"\"Set user prime status\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    UPDATE users \n                    SET is_prime = ?, prime_expiry = ?\n                    WHERE user_id = ?\n                \"\"\", (is_prime, expiry, user_id))\n                await db.commit()\n        except Exception as e:\n            logger.error(f\"Error setting prime status for user {user_id}: {e}\")\n    \n    async def log_download(self, user_id: int, url: str = \"\", quality: str = \"\", success: bool = True, error_message: str = \"\"):\n        \"\"\"Log download attempt\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute(\"\"\"\n                    INSERT INTO downloads (user_id, url, quality, success, error_message)\n                    VALUES (?, ?, ?, ?, ?)\n                \"\"\", (user_id, url, quality, success, error_message))\n                \n                # Update user downloads count\n                await db.execute(\"\"\"\n                    UPDATE users \n                    SET downloads_count = downloads_count + 1, last_seen = ?\n                    WHERE user_id = ?\n                \"\"\", (datetime.now().isoformat(), user_id))\n                \n                await db.commit()\n        except Exception as e:\n            logger.error(f\"Error logging download for user {user_id}: {e}\")\n    \n    async def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get bot statistics\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                # Get user counts\n                async with db.execute(\"SELECT COUNT(*) FROM users\") as cursor:\n                    total_users = (await cursor.fetchone())[0]\n                \n                async with db.execute(\"SELECT COUNT(*) FROM users WHERE is_prime = TRUE\") as cursor:\n                    prime_users = (await cursor.fetchone())[0]\n                \n                # Get download counts\n                async with db.execute(\"SELECT COUNT(*) FROM downloads\") as cursor:\n                    total_downloads = (await cursor.fetchone())[0]\n                \n                async with db.execute(\"SELECT COUNT(*) FROM downloads WHERE success = TRUE\") as cursor:\n                    successful_downloads = (await cursor.fetchone())[0]\n                \n                # Get recent activity\n                async with db.execute(\"\"\"\n                    SELECT COUNT(*) FROM users \n                    WHERE last_seen > datetime('now', '-24 hours')\n                \"\"\") as cursor:\n                    active_24h = (await cursor.fetchone())[0]\n                \n                return {\n                    'total_users': total_users,\n                    'prime_users': prime_users,\n                    'total_downloads': total_downloads,\n                    'successful_downloads': successful_downloads,\n                    'active_24h': active_24h,\n                    'success_rate': round((successful_downloads / max(total_downloads, 1)) * 100, 2)\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error getting stats: {e}\")\n            return {\n                'total_users': 0,\n                'prime_users': 0,\n                'total_downloads': 0,\n                'successful_downloads': 0,\n                'active_24h': 0,\n                'success_rate': 0\n            }\n    \n    async def get_all_users(self):\n        \"\"\"Get all users for broadcasting\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                db.row_factory = aiosqlite.Row\n                async with db.execute(\"SELECT user_id FROM users\") as cursor:\n                    users = await cursor.fetchall()\n                    return [user['user_id'] for user in users]\n        except Exception as e:\n            logger.error(f\"Error getting all users: {e}\")\n            return []","size_bytes":7743},"utils/download_manager_simple.py":{"content":"\"\"\"\nSimple Download Manager for Telegram YouTube Downloader Bot\n\"\"\"\n\nimport os\nimport asyncio\nimport logging\nimport tempfile\nimport time\nimport json\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\nimport yt_dlp\nfrom aiogram.types import BufferedInputFile\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass DownloadResult:\n    \"\"\"Download result with metadata\"\"\"\n    success: bool\n    type: str  # 'video' or 'audio'\n    file: Optional[BufferedInputFile] = None\n    quality: str = \"\"\n    title: str = \"\"\n    duration: int = 0\n    file_size: int = 0\n    error: Optional[str] = None\n\nclass AdvancedDownloadManager:\n    def __init__(self, max_concurrent: int = 5, temp_dir: str = \"temp\", cleanup_interval: int = 3600):\n        \"\"\"Initialize download manager\"\"\"\n        self.max_concurrent = max_concurrent\n        self.temp_dir = temp_dir\n        self.cleanup_interval = cleanup_interval\n        \n        # Create directories\n        os.makedirs(temp_dir, exist_ok=True)\n        \n        # Concurrent download management\n        self.semaphore = asyncio.Semaphore(max_concurrent)\n        \n        # Quality mappings\n        self.quality_formats = {\n            'quality_360p': 'best[height<=360][ext=mp4]',\n            'quality_480p': 'best[height<=480][ext=mp4]',\n            'quality_720p': 'best[height<=720][ext=mp4]',\n            'quality_1080p': 'best[height<=1080][ext=mp4]',\n            'audio_standard': 'bestaudio[ext=m4a]/bestaudio',\n            'audio_hq': 'bestaudio[abr>=128][ext=m4a]/bestaudio'\n        }\n        \n        # Error handling\n        self.retry_attempts = 3\n        self.retry_delay = 5\n    \n    def get_ydl_options(self, quality: str, output_path: str) -> Dict[str, Any]:\n        \"\"\"Get optimized yt-dlp options\"\"\"\n        base_opts = {\n            'quiet': True,\n            'no_warnings': True,\n            'extractaudio': quality.startswith('audio_'),\n            'format': self.quality_formats.get(quality, 'best'),\n            'outtmpl': output_path,\n            'writeinfojson': False,\n            'writethumbnail': False,\n            'writesubtitles': False,\n            'writeautomaticsub': False,\n            'ignoreerrors': False,\n            'retries': self.retry_attempts,\n            'fragment_retries': self.retry_attempts,\n            'socket_timeout': 30,\n            'prefer_ffmpeg': True,\n            'keepvideo': False,\n            'embed_subs': False\n        }\n        \n        # Cookies support\n        cookies_path = 'cookies/cookies.txt'\n        if os.path.exists(cookies_path):\n            base_opts['cookiefile'] = cookies_path\n        \n        # Audio-specific options\n        if quality.startswith('audio_'):\n            base_opts.update({\n                'audioformat': 'mp3',\n                'audioquality': '0' if quality == 'audio_hq' else '5',\n                'embed_thumbnail': False\n            })\n        \n        return base_opts\n    \n    async def download_content(self, url: str, quality: str, user_id: int) -> DownloadResult:\n        \"\"\"Download content with progress tracking\"\"\"\n        try:\n            # Use semaphore for concurrent download limiting\n            async with self.semaphore:\n                return await self._perform_download(url, quality, user_id)\n        except Exception as e:\n            logger.error(f\"Download error for user {user_id}: {e}\")\n            return DownloadResult(\n                success=False,\n                type='unknown',\n                error=str(e)\n            )\n    \n    async def _perform_download(self, url: str, quality: str, user_id: int) -> DownloadResult:\n        \"\"\"Perform the actual download\"\"\"\n        timestamp = int(time.time())\n        \n        if quality.startswith('audio_'):\n            filename = f\"audio_{user_id}_{timestamp}.%(ext)s\"\n            download_type = 'audio'\n        else:\n            filename = f\"video_{user_id}_{timestamp}.%(ext)s\"\n            download_type = 'video'\n        \n        output_path = os.path.join(self.temp_dir, filename)\n        \n        # Get yt-dlp options\n        ydl_opts = self.get_ydl_options(quality, output_path)\n        \n        try:\n            # Download using yt-dlp\n            with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n                info = await asyncio.to_thread(ydl.extract_info, url, download=True)\n                \n                # Find the downloaded file\n                downloaded_file = ydl.prepare_filename(info)\n                \n                # Handle audio extraction case\n                if quality.startswith('audio_'):\n                    # Check for various audio formats\n                    for ext in ['.mp3', '.m4a', '.webm', '.opus']:\n                        audio_file = os.path.splitext(downloaded_file)[0] + ext\n                        if os.path.exists(audio_file):\n                            downloaded_file = audio_file\n                            break\n                \n                if not os.path.exists(downloaded_file):\n                    return DownloadResult(\n                        success=False,\n                        type=download_type,\n                        error=\"Downloaded file not found\"\n                    )\n                \n                # Check file size\n                file_size = os.path.getsize(downloaded_file)\n                if file_size > 50 * 1024 * 1024:  # 50MB limit\n                    os.remove(downloaded_file)\n                    return DownloadResult(\n                        success=False,\n                        type=download_type,\n                        error=\"File too large (max 50MB)\"\n                    )\n                \n                # Read file and create BufferedInputFile\n                with open(downloaded_file, 'rb') as f:\n                    file_data = f.read()\n                \n                # Clean up downloaded file\n                try:\n                    os.remove(downloaded_file)\n                except:\n                    pass\n                \n                # Create appropriate input file\n                title = info.get('title', 'download')\n                safe_title = \"\".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()[:50]\n                \n                if download_type == 'video':\n                    filename = f\"{safe_title}.mp4\"\n                else:\n                    filename = f\"{safe_title}.mp3\"\n                \n                buffered_file = BufferedInputFile(file_data, filename)\n                \n                return DownloadResult(\n                    success=True,\n                    type=download_type,\n                    file=buffered_file,\n                    quality=quality,\n                    title=info.get('title', 'Unknown'),\n                    duration=info.get('duration', 0),\n                    file_size=file_size\n                )\n                \n        except Exception as e:\n            logger.error(f\"Download error: {e}\")\n            return DownloadResult(\n                success=False,\n                type=download_type,\n                error=str(e)\n            )","size_bytes":7057},"utils/security_simple.py":{"content":"\"\"\"\nSimple Security module for input validation and protection\n\"\"\"\n\nimport re\nimport time\nimport logging\nfrom typing import Dict, Set\nfrom urllib.parse import urlparse\n\nlogger = logging.getLogger(__name__)\n\nclass SecurityManager:\n    def __init__(self):\n        \"\"\"Initialize security manager\"\"\"\n        self.failed_attempts: Dict[int, int] = {}\n        self.blocked_users: Set[int] = set()\n        self.rate_limits: Dict[int, Dict[str, int]] = {}\n    \n    def is_valid_youtube_url(self, url: str) -> bool:\n        \"\"\"Check if URL is a valid YouTube URL\"\"\"\n        try:\n            parsed = urlparse(url)\n            return parsed.netloc in ['www.youtube.com', 'youtube.com', 'youtu.be', 'm.youtube.com']\n        except:\n            return False\n    \n    def is_user_blocked(self, user_id: int) -> bool:\n        \"\"\"Check if user is blocked\"\"\"\n        return user_id in self.blocked_users\n    \n    def block_user(self, user_id: int):\n        \"\"\"Block a user\"\"\"\n        self.blocked_users.add(user_id)\n        logger.warning(f\"User {user_id} has been blocked\")\n    \n    def unblock_user(self, user_id: int):\n        \"\"\"Unblock a user\"\"\"\n        self.blocked_users.discard(user_id)\n        logger.info(f\"User {user_id} has been unblocked\")","size_bytes":1236},"utils/user_manager_simple.py":{"content":"\"\"\"\nSimple User Manager for Telegram YouTube Downloader Bot\n\"\"\"\n\nimport logging\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\nclass ProfessionalUserManager:\n    def __init__(self, database, cache_ttl: int = 300, analytics_enabled: bool = True):\n        \"\"\"Initialize user manager\"\"\"\n        self.db = database\n        self.cache_ttl = cache_ttl\n        self.analytics_enabled = analytics_enabled\n        \n        # In-memory caches\n        self.user_cache = {}\n        self.cache_timestamps = {}\n        \n        # User state management\n        self.user_states: Dict[int, str] = {}\n        self.user_temp_data: Dict[int, Dict[str, Any]] = defaultdict(dict)\n        \n        # Rate limiting\n        self.user_downloads: Dict[int, list] = defaultdict(list)\n        self.blocked_users = set()\n    \n    async def initialize_user(self, user_id: int, username: str):\n        \"\"\"Initialize user in database\"\"\"\n        try:\n            await self.db.add_user(user_id, username)\n        except Exception as e:\n            logger.error(f\"Error initializing user {user_id}: {e}\")\n    \n    async def get_user_status(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get user status including download limits\"\"\"\n        try:\n            user_data = await self.db.get_user(user_id)\n            if not user_data:\n                return {\n                    'can_download': True,\n                    'downloads_remaining': 15,\n                    'is_prime': False,\n                    'prime_expiry': None,\n                    'reset_time': 'Next hour'\n                }\n            \n            is_prime = user_data.get('is_prime', False)\n            \n            if is_prime:\n                return {\n                    'can_download': True,\n                    'downloads_remaining': 999,\n                    'is_prime': True,\n                    'prime_expiry': user_data.get('prime_expiry'),\n                    'reset_time': 'N/A'\n                }\n            \n            # Check download limits for normal users\n            current_hour = int(time.time() // 3600)\n            downloads_this_hour = self.user_downloads[user_id]\n            \n            # Clean old downloads\n            cutoff_time = time.time() - 3600  # 1 hour ago\n            self.user_downloads[user_id] = [t for t in downloads_this_hour if t > cutoff_time]\n            \n            downloads_remaining = max(0, 15 - len(self.user_downloads[user_id]))\n            can_download = downloads_remaining > 0\n            \n            next_reset = datetime.fromtimestamp((current_hour + 1) * 3600)\n            \n            return {\n                'can_download': can_download,\n                'downloads_remaining': downloads_remaining,\n                'is_prime': False,\n                'prime_expiry': None,\n                'reset_time': next_reset.strftime('%H:%M')\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting user status: {e}\")\n            return {\n                'can_download': True,\n                'downloads_remaining': 15,\n                'is_prime': False,\n                'prime_expiry': None,\n                'reset_time': 'Next hour'\n            }\n    \n    async def update_usage(self, user_id: int):\n        \"\"\"Update user download usage\"\"\"\n        try:\n            current_time = time.time()\n            self.user_downloads[user_id].append(current_time)\n            await self.db.log_download(user_id)\n        except Exception as e:\n            logger.error(f\"Error updating usage for user {user_id}: {e}\")\n    \n    async def get_downloads_remaining(self, user_id: int) -> int:\n        \"\"\"Get remaining downloads for user\"\"\"\n        status = await self.get_user_status(user_id)\n        return status['downloads_remaining']\n    \n    async def set_user_state(self, user_id: int, state: str):\n        \"\"\"Set user state\"\"\"\n        self.user_states[user_id] = state\n    \n    async def get_user_state(self, user_id: int) -> Optional[str]:\n        \"\"\"Get user state\"\"\"\n        return self.user_states.get(user_id)\n    \n    async def clear_user_state(self, user_id: int):\n        \"\"\"Clear user state\"\"\"\n        self.user_states.pop(user_id, None)\n    \n    async def set_user_data(self, user_id: int, key: str, value: Any):\n        \"\"\"Set temporary user data\"\"\"\n        self.user_temp_data[user_id][key] = value\n    \n    async def get_user_data(self, user_id: int, key: str) -> Any:\n        \"\"\"Get temporary user data\"\"\"\n        return self.user_temp_data[user_id].get(key)\n    \n    async def clear_user_data(self, user_id: int):\n        \"\"\"Clear temporary user data\"\"\"\n        self.user_temp_data[user_id].clear()","size_bytes":4759}},"version":1}
